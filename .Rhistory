a0_0 = as.matrix(rep(0, r))
P0_0 = matrix(corpcor::pseudoinverse(diag(r*r)- kronecker(A.tilde,A.tilde)) %*% matrix(Sigma.u.tilde, ncol = 1), r, r)
P0_0
eigen(P0_0)$values
P0_0 = matrix(solve(diag(r*r)- kronecker(A.tilde,A.tilde)) %*% matrix(Sigma.u.tilde, ncol = 1), r, r)
P0_0
eigen(P0_0)$valuers
eigen(P0_0)$values
A.tilde
eigen(A.tilde)
Sigma.u.tilde
eigen(Sigma.u.tilde)
X = as.matrix(inflation)
fit <- dfms::DFM(X, r = 3, p = 5, rQ = 'none', rR = 'diagonal', em.method = 'BM', pos.corr = TRUE)
fit <- dfms::DFM(X, r = 3, p = 3, rQ = 'none', rR = 'diagonal', em.method = 'BM', pos.corr = TRUE)
dd = diag(r*r)- kronecker(A.tilde,A.tilde)
eigen(dd)
dd
image(dd)
A.tilde
eigen(A.tilde)$values
X
image(X)
install.packages('naniar')
library(naniar)
vis_miss(X)
vis_miss(as.data.frame(X))
X[ , colSums(is.na(X))==0]
XX = X[ , colSums(is.na(X))==0]
tune_factors(X, plot = TRUE)
tune_factors(XX, plot = TRUE)
fit <- dfms::DFM(XX, r = 3, p = 1, rQ = 'none', rR = 'diagonal', em.method = 'BM', pos.corr = TRUE)
fit2 <- Sparse_DFM(XX, r = 3, q =0, alg = 'EM', err = 'IID', kalman = 'multivariate')
X = as.matrix(inflation)
X = diff(X)
tune_factors(X, plot = TRUE)
r = 3
q = 0
alg = 'EM'
err = 'IID'
standardize = TRUE
alphas = logspace(-2,3,100)
sparse = FALSE
kalman = 'multivariate'
max_iter=100
threshold=1e-4
n = dim(X)[1]
p = dim(X)[2]
k = r + p
# standardize if TRUE
X.raw = X
X.scale = scale(X)
X.mean = attr(X.scale, "scaled:center")
X.sd = attr(X.scale, "scaled:scale")
if(standardize){
X = X.scale
}
initialise <- initPCA(X,r,err)
a0_0 = initialise$a0_0
P0_0 = initialise$P0_0
A.tilde = initialise$A.tilde
Lambda.tilde = initialise$Lambda.tilde
Sigma.u.tilde = initialise$Sigma.u.tilde
Sigma.eta = initialise$Sigma.eta
factors.PCA = initialise$factors.pca
loadings.PCA = initialise$loadings.pca
P0_0
eigen(P0_0)$values
X = as.matrix(inflation)
r = 3
q = 0
alg = 'EM'
err = 'IID'
standardize = TRUE
alphas = logspace(-2,3,100)
sparse = FALSE
kalman = 'multivariate'
max_iter=100
threshold=1e-4
n = dim(X)[1]
p = dim(X)[2]
k = r + p
# standardize if TRUE
X.raw = X
X.scale = scale(X)
X.mean = attr(X.scale, "scaled:center")
X.sd = attr(X.scale, "scaled:scale")
if(standardize){
X = X.scale
}
initialise <- initPCA(X,r,err)
a0_0 = initialise$a0_0
P0_0 = initialise$P0_0
A.tilde = initialise$A.tilde
Lambda.tilde = initialise$Lambda.tilde
Sigma.u.tilde = initialise$Sigma.u.tilde
Sigma.eta = initialise$Sigma.eta
factors.PCA = initialise$factors.pca
loadings.PCA = initialise$loadings.pca
P0_0
eigen(P0_0)$values
diag(P0_0)
diag(P0_0) = diag(P0_0)+0.5
P0_0
eigen(P0_0)
P0_0 = initialise$P0_0
diag(P0_0) = diag(P0_0)+2
P0_0
eigen(P0_0)
n = dim(X)[1]
p = dim(X)[2]
k = dim(A.tilde)[1]
r = k
previous_loglik = -.Machine$double.xmax   # at least 2 iterations
num_iter = 0        # counter begins at 0
converged = 0       # convergence initialised to FALSE
loglik.store = c()  # store log likelihoods
W = 1*!is.na(X)   # data availability - n x p - 0 for missing, 1 for observed
while ((num_iter < max_iter) & !converged) {
## E-step
if(kalman == 'univariate'){
KFS <- kalmanUnivariate(X, a0_0, P0_0, A.tilde, Lambda.tilde, Sigma.eta, Sigma.u.tilde)
}else{
KFS <- kalmanCpp(X, a0_0, P0_0, A.tilde, Lambda.tilde, Sigma.eta, Sigma.u.tilde)
}
at_n = KFS$at_n             # state mean: k x n matrix (t=1,...,n)
Pt_n = KFS$Pt_n             # state covariance: k x k x n array (t=1,...,n)
Pt_tlag_n = KFS$Pt_tlag_n   # state covariance with lag: k x k x n array (t=1,...,n)
loglik = KFS$logl           # log-likelihood value
num_iter = num_iter + 1     # new iteration
## M-step
## Initial state mean and covariance update
a0_0 = as.matrix(at_n[,1])
P0_0 = as.matrix(Pt_n[,,1])
## State transition equation parameter updates: A.tilde and Sigma.u.tilde
## required sums for the update equations
if(r == 1){
E_Ft_Ftlag = crossprod(at_n[1:r,2:n], at_n[1:r,1:(n-1)]) + sum(Pt_tlag_n[1:r,1:r,])
E_Ftlag_Ftlag = crossprod(at_n[1:r,1:(n-1)], at_n[1:r,1:(n-1)]) + sum(Pt_n[1:r,1:r,1:(n-1)])
E_Ft_Ft = crossprod(at_n[1:r,2:n], at_n[1:r,2:n]) + sum(Pt_n[1:r,1:r,2:n])
E_Ftlag_Ft = crossprod(at_n[1:r,1:(n-1)], at_n[1:r,2:n]) + sum(Pt_tlag_n[1:r,1:r,])
}else{
E_Ft_Ftlag = tcrossprod(at_n[1:r,2:n], at_n[1:r,1:(n-1)]) + rowSums(Pt_tlag_n[1:r,1:r,], dims = 2L)
E_Ftlag_Ftlag = tcrossprod(at_n[1:r,1:(n-1)], at_n[1:r,1:(n-1)]) + rowSums(Pt_n[1:r,1:r,1:(n-1)], dims = 2L)
E_Ft_Ft = tcrossprod(at_n[1:r,2:n], at_n[1:r,2:n]) + rowSums(Pt_n[1:r,1:r,2:n], dims = 2L)
E_Ftlag_Ft = tcrossprod(at_n[1:r,1:(n-1)], at_n[1:r,2:n]) + rowSums(Pt_tlag_n[1:r,1:r,], dims = 2L)
}
## A update
A = E_Ft_Ftlag %*% solve(E_Ftlag_Ftlag)
A.tilde = A
## Sig_u update
Sig_u = (E_Ft_Ft - A %*% E_Ftlag_Ft)/n
Sig.u.tilde = Sig_u
## Measurement equation parameter updates: Lambda.tilde and Sigma.eta
## Lambda.tilde update (ADMM algorithm for lasso regularisation - see paper)
y = t(X)
y[is.na(y)] = 0
## Calculate components A, B and C in the fast algorithm for Lambda computation (see paper)
##
## At: r x r x n array
## Bt: p x p matrix
## Ct: p x r matrix
At = array(NA, dim=c(r, r, n))
Bt = matrix(NA, nrow = p, ncol = n)
Ct = 0
Sigma.eta.inv = 1/diag(Sigma.eta)
for(t in 1:n){
At[,,t] = at_n[1:r,t] %*% t(at_n[1:r,t]) + Pt_n[1:r,1:r,t]
Bt[,t] = W[t,]*Sigma.eta.inv*W[t,]
Ct = Ct + as.matrix(Bt[,t]*y[,t]) %*% at_n[1:r,t]
}
## Estimating loadings: with or without sparsity
if(sparse){
## Solve fast algorithm for Lambda
D_cube = solveCube(At, Bt, nu = 1)
sol = solveLambda(D_cube, Ct, nu = 1, alpha = alpha.lasso)
Lambda = sol$Z
## Lambda.tilde construction
Lambda.tilde = Lambda
}else{
D_cube = solveCube(At, Bt, nu = 0)
Lambda = fastLambda(D_cube, Ct)
Lambda.tilde = Lambda
}
## Sigma.eta update
Sig_e_new = 0
I = rep(1,p)
for(t in 1:n){
Sig_e_new = Sig_e_new + (tcrossprod(W[t,]*y[,t]) - tcrossprod(W[t,]*y[,t],W[t,]*Lambda%*%at_n[1:r,t])
- tcrossprod(W[t,]*Lambda%*%at_n[1:r,t],W[t,]*y[,t]) + tcrossprod(W[t,]*Lambda%*%(At[,,t]),W[t,]*Lambda)
+ diag((I - W[t,])*diag(Sigma.eta)*(I - W[t,])))
}
Sig_e = Sig_e_new/n
Sig_e = diag(diag(Sig_e))
Sigma.eta = Sig_e
if(any(diag(Sigma.eta)<0.001)){
converged = TRUE
previous_loglik <- loglik
loglik.store[num_iter] = loglik
}else{
## Check convergence
converged <- emConverged(loglik, previous_loglik, threshold)
previous_loglik <- loglik
loglik.store[num_iter] = loglik
}
}
View(Sparse_DFM)
X = as.matrix(inflation)
r = 3
q = 0
alg = 'EM'
err = 'IID'
standardize = TRUE
alphas = logspace(-2,3,100)
sparse = FALSE
kalman = 'multivariate'
max_iter=100
threshold=1e-4
n = dim(X)[1]
p = dim(X)[2]
k = r + p
# standardize if TRUE
X.raw = X
X.scale = scale(X)
X.mean = attr(X.scale, "scaled:center")
X.sd = attr(X.scale, "scaled:scale")
if(standardize){
X = X.scale
}
initialise <- initPCA(X,r,err)
a0_0 = initialise$a0_0
P0_0 = initialise$P0_0
A.tilde = initialise$A.tilde
Lambda.tilde = initialise$Lambda.tilde
Sigma.u.tilde = initialise$Sigma.u.tilde
Sigma.eta = initialise$Sigma.eta
factors.PCA = initialise$factors.pca
loadings.PCA = initialise$loadings.pca
diag(P0_0) = diag(P0_0)+2
# EM iterations function
EM.fit <- EM(X, a0_0, P0_0, A.tilde, Lambda.tilde, Sigma.eta, Sigma.u.tilde,
err = err, kalman = kalman, sparse = FALSE, max_iter = max_iter, threshold = threshold)
a0_0 = EM.fit$a0_0
P0_0 = EM.fit$P0_0
A.tilde = EM.fit$A.tilde
Lambda.tilde = EM.fit$Lambda.tilde
Sigma.u.tilde = EM.fit$Sigma.u.tilde
Sigma.eta = EM.fit$Sigma.eta
loglik.store = EM.fit$loglik.store
converged = EM.fit$converged
num_iter = EM.fit$num_iter
if(kalman == 'univariate'){
best.KFS <- kalmanUnivariate(X, a0_0, P0_0, A.tilde, Lambda.tilde, Sigma.eta, Sigma.u.tilde)
}else{
best.KFS <- kalmanCpp(X, a0_0, P0_0, A.tilde, Lambda.tilde, Sigma.eta, Sigma.u.tilde)
}
state.EM = t(best.KFS$at_n)
covariance.EM = best.KFS$Pt_n
matplot(state.EM, type = 'l')
state.EM
X = as.matrix(inflation)
r = 3
q = 0
alg = 'EM'
err = 'IID'
standardize = TRUE
alphas = logspace(-2,3,100)
sparse = FALSE
kalman = 'multivariate'
max_iter=100
threshold=1e-4
n = dim(X)[1]
p = dim(X)[2]
k = r + p
# standardize if TRUE
X.raw = X
X.scale = scale(X)
X.mean = attr(X.scale, "scaled:center")
X.sd = attr(X.scale, "scaled:scale")
if(standardize){
X = X.scale
}
initialise <- initPCA(X,r,err)
a0_0 = initialise$a0_0
P0_0 = initialise$P0_0
A.tilde = initialise$A.tilde
Lambda.tilde = initialise$Lambda.tilde
Sigma.u.tilde = initialise$Sigma.u.tilde
Sigma.eta = initialise$Sigma.eta
factors.PCA = initialise$factors.pca
loadings.PCA = initialise$loadings.pca
P0_0
matplot(factors.pca, type = 'l')
matplot(-factors.pca, type = 'l')
matplot(state.EM, type = 'l')
X = as.matrix(inflation)
r = 3
q = 0
alg = 'EM'
err = 'IID'
standardize = TRUE
alphas = logspace(-2,3,100)
sparse = FALSE
kalman = 'multivariate'
max_iter=100
threshold=1e-4
n = dim(X)[1]
p = dim(X)[2]
k = r + p
# standardize if TRUE
X.raw = X
X.scale = scale(X)
X.mean = attr(X.scale, "scaled:center")
X.sd = attr(X.scale, "scaled:scale")
if(standardize){
X = X.scale
}
initialise <- initPCA(X,r,err)
a0_0 = initialise$a0_0
P0_0 = initialise$P0_0
A.tilde = initialise$A.tilde
Lambda.tilde = initialise$Lambda.tilde
Sigma.u.tilde = initialise$Sigma.u.tilde
Sigma.eta = initialise$Sigma.eta
factors.PCA = initialise$factors.pca
loadings.PCA = initialise$loadings.pca
P0_0
Matrix::nearPD(P0_0)
Matrix::nearPD(P0_0)$matrix
Matrix::nearPD(P0_0)$ma
Matrix::nearPD(P0_0)$mat
P0_0
diag(P0_0) = diag(P0_0)+2
P0_0
P0_0 = initialise$P0_0
any(eigen(P0_0)<0)
any(eigen(P0_0)$values < 0)
source("C:/Users/mosleyl/OneDrive - Lancaster University/PhD/Nowcasting/Sparse DFM/SparseDFM-main - Copy/R/initPCA.R", echo=TRUE)
if(any(eigen(P0_0)$values < 0)){
P0_0 = Matrix::nearPD(P0_0, doSym = TRUE)
}
P0_0
P0_0 = initialise$P0_0
if(any(eigen(P0_0)$values < 0)){
P0_0 = Matrix::nearPD(P0_0, doSym = TRUE)$mat
}
P0_0
P0_0 = as.matrix(P0_0)
P0_0
initPCA <- function(X,r,err='AR1') {
# interpolate the missing data in X
fillNA = fill_NA(X)
X.balanced<- fillNA$X
X.NAidx <- fillNA$idx.na
n <- dim(X.balanced)[1] # n observations
p <- dim(X.balanced)[2] # p time series
## PCA on balanced panel
evd = eigen(cov(X.balanced))
loadings.pca = as.matrix(evd$vectors[,1:r]) # (p x r)
loadings.pca[,which(colSums(loadings.pca)<0)] = -loadings.pca[,which(colSums(loadings.pca)<0)] # flip sign
factors.pca = X.balanced %*% loadings.pca # (n x r)
factors = factors.pca
## Two error structures: err = 'AR1' or err = 'IID'
if(err == 'AR1'){
## Measurement equation parameters
#
## Lambda.tilde = [Lambda I_p] is p x (r+p)
## Sigma.eta = \kappa*I_p where \kappa is a small number
Lambda.tilde = cbind(loadings.pca, diag(p))
kappa = 1e-4
Sigma.eta = kappa*diag(p)
## State equation parameters
#
## A.tilde = [A 0; 0 Phi] is (r+p) x (r+p)
## Sigma.u.tilde = [Sigma_u 0; 0 Sigma_{epsilon}] is (r+p) x (r+p)
VAR_fit =  VAR(factors, 1)
A = t(VAR_fit$A)
Sigma_u = cov(VAR_fit$res)
e = X.balanced - factors %*% t(loadings.pca)
e[X.NAidx] <- NA # do not consider missing data when working out these parameters
phi = sigma = c()
for(i in 1:p){
ei = na.omit(e[,i])
n_ei = length(ei)
phi[i] = solve(ei[1:(n_ei-1)]%*%ei[1:(n_ei-1)])%*%ei[1:(n_ei-1)]%*%ei[2:(n_ei)]
sigma[i] = var(ei[2:(n_ei)]-phi[i]*ei[1:(n_ei-1)])
}
Phi = diag(phi)
Sigma_epsilon = diag(sigma)
A.tilde = blkdiag(A, Phi)
Sigma.u.tilde = blkdiag(Sigma_u, Sigma_epsilon)
## Initial mean and variance of state
#
# a0_0 is (r+p)x1 mean of state at t=0
# P0_0 is (r+p)x(r+p) variance of state at t=0
a0_0 = as.matrix(rep(0, r+p))
P_F = matrix(corpcor::pseudoinverse(diag(r*r)- kronecker(A,A)) %*% matrix(Sigma_u, ncol = 1), r, r)
P_eps = diag(1 / diag(diag(dim(Phi)[1]) - Phi ^ 2)) * Sigma_epsilon
P0_0 = blkdiag(P_F, P_eps) # covariance of F and e initialised to be 0
}else { # IID errors
## Measurement equation parameters: Lambda and Sig_e
Lambda.tilde = loadings.pca
e = X.balanced - factors %*% t(loadings.pca)
e[X.NAidx] <- NA # do not consider missing data when working out these parameters
sigma = c()
for(i in 1:p){
ei = na.omit(e[,i])
sigma[i] = var(ei)
}
Sigma.eta = diag(sigma)
## State equation parameters: A and Sig_u
VAR_fit =  VAR(factors, 1)
A.tilde = t(VAR_fit$A)
Sigma.u.tilde = cov(VAR_fit$res)
## Initial mean and variance of state
#
# a0_0 is rx1 mean of state at t=0
# P0_0 is rxr variance of state at t=0
a0_0 = as.matrix(rep(0, r))
P0_0 = matrix(corpcor::pseudoinverse(diag(r*r)- kronecker(A.tilde,A.tilde)) %*% matrix(Sigma.u.tilde, ncol = 1), r, r)
if(any(eigen(P0_0)$values < 0)){
warning('eiegnvalues are negative')
P0_0 = Matrix::nearPD(P0_0, doSym = TRUE)$mat
P0_0 = as.matrix(P0_0)
}
}
output = list('a0_0' = a0_0, 'P0_0' = P0_0, 'factors.pca' = factors.pca,
'loadings.pca' = loadings.pca, 'A.tilde' = A.tilde, 'Sigma.u.tilde' = Sigma.u.tilde,
'Lambda.tilde' = Lambda.tilde, 'Sigma.eta' = Sigma.eta, 'X.bal' = X.balanced,
'eigen' = evd)
return(output)
}
X = as.matrix(inflation)
fit <- dfms::DFM(XX, r = 3, p = 1, rQ = 'none', rR = 'diagonal', em.method = 'BM', pos.corr = TRUE)
fit2 <- Sparse_DFM(X, r = 3, q =0, alg = 'EM', err = 'IID', kalman = 'multivariate')
setwd('C:/Users/mosleyl/OneDrive - Lancaster University/PhD/Nowcasting/Sparse DFM/SparseDFM-main/SparseDFM')
library(devtools)
library(roxygen2)
devtools::load_all()
document()
?kalmanUnivariate
check()
setwd('C:/Users/mosleyl/OneDrive - Lancaster University/PhD/Nowcasting/Sparse DFM/SparseDFM-main/SparseDFM')
library(devtools)
library(roxygen2)
devtools::load_all()
document()
check()
setwd('C:/Users/mosleyl/OneDrive - Lancaster University/PhD/Nowcasting/Sparse DFM/SparseDFM-main/SparseDFM')
library(devtools)
library(roxygen2)
devtools::load_all()
document()
check()
setwd('C:/Users/mosleyl/OneDrive - Lancaster University/PhD/Nowcasting/Package/SparseDFM')
library(devtools)
library(roxygen2)
devtools::load_all()
document()
check()
load("C:/Users/mosleyl/OneDrive - Lancaster University/PhD/Nowcasting/Sparse DFM/SparseDFM-main - Copy/inflation.rda")
X = as.matrix(inflation)
X = diff(X)
?dfms::DFM
fit <- dfms::DFM(X, r = 3, p = 1, rQ = 'none', rR = 'diagonal', em.method = 'none', pos.corr = TRUE)
fit$X_imp$
fit$X_imp
fit$X_imp
?SparseDFM
?EM
?DFM
dd = fit$X_imp
View(dd)
X = as.matrix(inflation)
X = diff(X)
fit2 <- Sparse_DFM(X, r = 3, q =0, alg = 'EM', err = 'IID', kalman = 'multivariate')
fit2 <- SparseDFM(X, r = 3, q =0, alg = 'EM', err = 'IID', kalman = 'multivariate')
fit2$data$standardize
fit2$data$X.mean
str(fit2$data$X.mean)
str(fit2$data$X.sd)
fit2 <- SparseDFM(X, r = 3, q =0, alg = 'EM', err = 'AR1', kalman = 'multivariate')
str(fit2$params$Phi)
fit2$state$factors
dim(fit2$state$errors)
dim(fit2$state$factors.cov)
dim(fit2$state$errors.cov)
fit2 <- SparseDFM(X, r = 3, q =0, alg = 'EM-sparse', err = 'IID', kalman = 'univariate')
X = as.matrix(inflation)
X = diff(X)
fit2 <- SparseDFM(X, r = 3, q =0, alg = 'EM', err = 'IID', kalman = 'univariate')
fit2 <- SparseDFM(X, r = 3, q =0, alg = 'EM-sparse', err = 'IID', kalman = 'univariate')
fit2$converged$loglik
fit2$converged$num_iter
fit2$converged$max_iter
X = as.matrix(inflation)
X = diff(X)
fit2 <- SparseDFM(X, r = 3, q =0, alg = 'EM', err = 'IID', kalman = 'univariate')
fit2$converged$num_iter
setwd('C:/Users/mosleyl/OneDrive - Lancaster University/PhD/Nowcasting/Package/SparseDFM')
library(devtools)
library(roxygen2)
devtools::load_all()
document()
?SparseDFM
setwd('C:/Users/mosleyl/OneDrive - Lancaster University/PhD/Nowcasting/Package/SparseDFM')
setwd('C:/Users/mosleyl/OneDrive - Lancaster University/PhD/Nowcasting/Package/SparseDFM')
library(devtools)
library(roxygen2)
devtools::load_all()
document()
?SparseDFM
