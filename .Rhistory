}else if(yidx==2){
Y = Y3
pp = p3
}else if(yidx==3){
Y = Y4
pp = p4
}else{
Y = Y5
pp = p5
}
true.x = X[n,pp]
# DFM fit
fit.dfm <- sparseDFM(Y, r = r, q = 0, alg = 'EM', err = 'IID', kalman = 'univariate',
standardize = TRUE, max_iter = 100, threshold = 1e-4)
dfm.est = fit.dfm$data$fitted.unscaled
dfm.est = dfm.est[n,pp]
dfm.mae[yidx] = mean(abs(dfm.est - true.x))
dfm.rmse[yidx] = sqrt(mean((dfm.est - true.x)^2))
#
# #sparseDFM fit
fit.sdfm <- sparseDFM(Y, r = r, q = 0, alg = 'EM-sparse', err = 'IID', kalman = 'univariate',
standardize = FALSE, max_iter = 100, threshold = 1e-4)
sdfm.est = fit.sdfm$data$fitted.unscaled
sdfm.est = sdfm.est[n,pp]
sdfm.mae[yidx] = mean(abs(sdfm.est - true.x))
sdfm.rmse[yidx] = sqrt(mean((sdfm.est - true.x)^2))
yidx = 2
if(yidx==1){
Y = Y2
pp = p2
}else if(yidx==2){
Y = Y3
pp = p3
}else if(yidx==3){
Y = Y4
pp = p4
}else{
Y = Y5
pp = p5
}
true.x = X[n,pp]
# DFM fit
fit.dfm <- sparseDFM(Y, r = r, q = 0, alg = 'EM', err = 'IID', kalman = 'univariate',
standardize = TRUE, max_iter = 100, threshold = 1e-4)
dfm.est = fit.dfm$data$fitted.unscaled
dfm.est = dfm.est[n,pp]
dfm.mae[yidx] = mean(abs(dfm.est - true.x))
dfm.rmse[yidx] = sqrt(mean((dfm.est - true.x)^2))
#
# #sparseDFM fit
fit.sdfm <- sparseDFM(Y, r = r, q = 0, alg = 'EM-sparse', err = 'IID', kalman = 'univariate',
standardize = FALSE, max_iter = 100, threshold = 1e-4)
sdfm.est = fit.sdfm$data$fitted.unscaled
sdfm.est = sdfm.est[n,pp]
sdfm.mae[yidx] = mean(abs(sdfm.est - true.x))
sdfm.rmse[yidx] = sqrt(mean((sdfm.est - true.x)^2))
tail(Y)
fill.NA = fillNA(X)
X.balanced<- fill.NA$X
X.NAidx <- fill.NA$idx.na
n <- dim(X.balanced)[1] # n observations
p <- dim(X.balanced)[2] # p time series
## PCA on balanced panel
evd = eigen(cov(X.balanced))
loadings.pca = as.matrix(evd$vectors[,1:r]) # (p x r)
loadings.pca[,which(colSums(loadings.pca)<0)] = -loadings.pca[,which(colSums(loadings.pca)<0)] # flip sign
factors.pca = X.balanced %*% loadings.pca # (n x r)
factors = factors.pca
loadings.pca
evd
Lambda.tilde = loadings.pca
e = X.balanced - factors %*% t(loadings.pca)
e[X.NAidx] <- NA # do not consider missing data when working out these parameters
sigma = c()
for(i in 1:p){
ei = na.omit(e[,i])
sigma[i] = var(ei)
}
Sigma.eta = diag(sigma)
## State equation parameters: A and Sig_u
VAR_fit =  VAR(factors, 1)
A.tilde = t(VAR_fit$A)
Sigma.u.tilde = cov(VAR_fit$res)
## Initial mean and variance of state
#
# a0_0 is rx1 mean of state at t=0
# P0_0 is rxr variance of state at t=0
a0_0 = as.matrix(rep(0, r))
P0_0 = matrix(solve(diag(r*r)- kronecker(A.tilde,A.tilde)) %*% matrix(Sigma.u.tilde, ncol = 1), r, r)
A.tilde
P0_0
eigen(P0_0)
X = Y
fill.NA = fillNA(X)
X.balanced<- fill.NA$X
X.NAidx <- fill.NA$idx.na
n <- dim(X.balanced)[1] # n observations
p <- dim(X.balanced)[2] # p time series
## PCA on balanced panel
evd = eigen(cov(X.balanced))
loadings.pca = as.matrix(evd$vectors[,1:r]) # (p x r)
loadings.pca[,which(colSums(loadings.pca)<0)] = -loadings.pca[,which(colSums(loadings.pca)<0)] # flip sign
factors.pca = X.balanced %*% loadings.pca # (n x r)
factors = factors.pca
Lambda.tilde = loadings.pca
e = X.balanced - factors %*% t(loadings.pca)
e[X.NAidx] <- NA # do not consider missing data when working out these parameters
sigma = c()
for(i in 1:p){
ei = na.omit(e[,i])
sigma[i] = var(ei)
}
Sigma.eta = diag(sigma)
## State equation parameters: A and Sig_u
VAR_fit =  VAR(factors, 1)
A.tilde = t(VAR_fit$A)
Sigma.u.tilde = cov(VAR_fit$res)
## Initial mean and variance of state
#
# a0_0 is rx1 mean of state at t=0
# P0_0 is rxr variance of state at t=0
a0_0 = as.matrix(rep(0, r))
P0_0 = matrix(solve(diag(r*r)- kronecker(A.tilde,A.tilde)) %*% matrix(Sigma.u.tilde, ncol = 1), r, r)
A.tilde
fit.dfm <- sparseDFM(Y, r = r, q = 0, alg = 'PCA', err = 'IID', kalman = 'univariate',
standardize = TRUE, max_iter = 100, threshold = 1e-4)
fit.dfm <- sparseDFM(Y, r = r, q = 0, alg = 'PCA', err = 'IID', kalman = 'univariate',
standardize = FALSE, max_iter = 100, threshold = 1e-4)
fit.dfm$params$A
fit.dfm <- sparseDFM(Y, r = r, q = 0, alg = 'PCA', err = 'IID', kalman = 'univariate',
standardize = TRUE, max_iter = 100, threshold = 1e-4)
fit.dfm$params$A
ar.est = c()
for(i in 1:length(pp)){
tryCatch({
fit.ar = arima(na.omit(Y[,pp[i]]), order=c(1,0,0))
ar.est[i] = as.numeric(predict(fit.ar,n.ahead = 3)$pred)[3]
}, error=function(e){})
}
fit.ar
as.numeric(predict(fit.ar,n.ahead = 3)$pred)[3]
fit.ar$coef
ar.est = c()
for(i in 1:length(pp)){
tryCatch({
fit.ar = arima(na.omit(Y[,pp[i]]), order=c(1,0,0))
print(fit.ar$coef[1])
ar.est[i] = as.numeric(predict(fit.ar,n.ahead = 3)$pred)[3]
}, error=function(e){})
}
A.tilde
A.tilde[A.tilde >= 1] = 0.99
A.tilde
setwd('C:/Users/mosleyl/OneDrive - Lancaster University/PhD/Nowcasting/Package/SparseDFM/')
devtools::load_all()
document()
fit.dfm <- sparseDFM(Y, r = r, q = 0, alg = 'PCA', err = 'IID', kalman = 'univariate',
standardize = TRUE, max_iter = 100, threshold = 1e-4)
fit.dfm$params$A
fit.dfm <- sparseDFM(Y, r = r, q = 0, alg = 'PCA', err = 'IID', kalman = 'univariate',
standardize = FALSE, max_iter = 100, threshold = 1e-4)
fit.dfm$params$A
X=Y
fill.NA = fillNA(X)
X.balanced<- fill.NA$X
X.NAidx <- fill.NA$idx.na
n <- dim(X.balanced)[1] # n observations
p <- dim(X.balanced)[2] # p time series
## PCA on balanced panel
evd = eigen(cov(X.balanced))
loadings.pca = as.matrix(evd$vectors[,1:r]) # (p x r)
loadings.pca[,which(colSums(loadings.pca)<0)] = -loadings.pca[,which(colSums(loadings.pca)<0)] # flip sign
factors.pca = X.balanced %*% loadings.pca # (n x r)
factors = factors.pca
Lambda.tilde = loadings.pca
e = X.balanced - factors %*% t(loadings.pca)
e[X.NAidx] <- NA # do not consider missing data when working out these parameters
sigma = c()
for(i in 1:p){
ei = na.omit(e[,i])
sigma[i] = var(ei)
}
Sigma.eta = diag(sigma)
## State equation parameters: A and Sig_u
VAR_fit =  VAR(factors, 1)
A.tilde = t(VAR_fit$A)
Sigma.u.tilde = cov(VAR_fit$res)
## Initial mean and variance of state
#
# a0_0 is rx1 mean of state at t=0
# P0_0 is rxr variance of state at t=0
a0_0 = as.matrix(rep(0, r))
P0_0 = matrix(solve(diag(r*r)- kronecker(A.tilde,A.tilde)) %*% matrix(Sigma.u.tilde, ncol = 1), r, r)
eigen(P0_0)
P0_0
if(any(eigen(P0_0)$values <= 0)){
warning('Initial covariance matrix of factors has negative eigenvalues. The nearest positive definite matrix to an approximate one is used instead.')
P0_0 = Matrix::nearPD(P0_0, doSym = TRUE)$mat
P0_0 = as.matrix(P0_0)
}
P0_0
fit.dfm <- sparseDFM(Y, r = r, q = 0, alg = 'PCA', err = 'IID', kalman = 'univariate',
standardize = TRUE, max_iter = 100, threshold = 1e-4)
fit.dfm$params$A
fit.dfm <- sparseDFM(Y, r = r, q = 0, alg = 'EM-sparse', err = 'IID', kalman = 'univariate',
standardize = TRUE, max_iter = 50, threshold = 1e-4)
fit.dfm$params$Lambda
fit.dfm <- sparseDFM(Y, r = r, q = 0, alg = 'EM-sparse', err = 'IID', kalman = 'univariate',
standardize = FALSE, max_iter = 50, threshold = 1e-4)
fit.dfm$params$Lambda
fit.dfm <- sparseDFM(Y, r = r, q = 0, alg = 'EM', err = 'IID', kalman = 'univariate',
standardize = TRUE, max_iter = 50, threshold = 1e-4)
fit.dfm$params$Lambda
library(caret)
id = 3
if(id == 1){
rho = 0
}else if(id == 2){
rho = 0.2
}else{
rho = 0.9
}
A = matrix(c(0.8,rho,0,
0,0.8,0,
rho,0,0.8),ncol=3,byrow=TRUE)
n = 100
p = 60
r = 3
num_exps = 100
sdfm.mae.nexp = sdfm.rmse.nexp = dfm.mae.nexp = dfm.rmse.nexp = ar.mae.nexp = ar.rmse.nexp = rep(0,4)
yidx=3
Lambda = kronecker(diag(r),rep(1,p/r))
factors = tsDyn::VAR.sim(A, n, include = 'none', varcov = (1-0.8^2)*diag(r))
errors = MASS::mvrnorm(n, mu = rep(0,p), Sigma = 0.2*diag(p))
X = factors %*% t(Lambda) + errors
p2 = c(1:(p/12),(p/3+1):(p/3+p/12),(2*p/3+1):(2*p/3+p/12))
p3 =c(1:(p/6),(p/3+1):(p/3+p/6),(2*p/3+1):(2*p/3+p/6))
p4 = c(1:(3*p/12),(p/3+1):(p/3+3*p/12),(2*p/3+1):(2*p/3+3*p/12))
p5 = 1:p
# 1/4 missing in each block
Y2 = X
Y2[c(n-2,n-1,n),p2] = NA
# 1/2 missing in each block
Y3 = X
Y3[c(n-2,n-1,n),p3] = NA
# 3/4 missing in each block
Y4 = X
Y4[c(n-2,n-1,n),p4] = NA
# All missing
Y5 = X
Y5[c(n-2,n-1,n),p5] = NA
if(yidx==1){
Y = Y2
pp = p2
}else if(yidx==2){
Y = Y3
pp = p3
}else if(yidx==3){
Y = Y4
pp = p4
}else{
Y = Y5
pp = p5
}
true.x = X[n,pp]
#
# #sparseDFM fit
fit.sdfm <- sparseDFM(Y, r = r, q = 0, alg = 'EM-sparse', err = 'IID', kalman = 'univariate',
standardize = FALSE, max_iter = 100, threshold = 1e-4)
n = 100
p = 60
r = 3
num_exps = 1
sdfm.mae.nexp = sdfm.rmse.nexp = dfm.mae.nexp = dfm.rmse.nexp = ar.mae.nexp = ar.rmse.nexp = rep(0,4)
for(nexp in 1:num_exps){
# Data
#set.seed(nexp)
Lambda = kronecker(diag(r),rep(1,p/r))
factors = tsDyn::VAR.sim(A, n, include = 'none', varcov = (1-0.8^2)*diag(r))
errors = MASS::mvrnorm(n, mu = rep(0,p), Sigma = 0.2*diag(p))
X = factors %*% t(Lambda) + errors
p2 = c(1:(p/12),(p/3+1):(p/3+p/12),(2*p/3+1):(2*p/3+p/12))
p3 =c(1:(p/6),(p/3+1):(p/3+p/6),(2*p/3+1):(2*p/3+p/6))
p4 = c(1:(3*p/12),(p/3+1):(p/3+3*p/12),(2*p/3+1):(2*p/3+3*p/12))
p5 = 1:p
# 1/4 missing in each block
Y2 = X
Y2[c(n-2,n-1,n),p2] = NA
# 1/2 missing in each block
Y3 = X
Y3[c(n-2,n-1,n),p3] = NA
# 3/4 missing in each block
Y4 = X
Y4[c(n-2,n-1,n),p4] = NA
# All missing
Y5 = X
Y5[c(n-2,n-1,n),p5] = NA
#################################
sdfm.mae = sdfm.rmse = dfm.mae = dfm.rmse = ar.mae = ar.rmse = c()
for(yidx in 1:4){
if(yidx==1){
Y = Y2
pp = p2
}else if(yidx==2){
Y = Y3
pp = p3
}else if(yidx==3){
Y = Y4
pp = p4
}else{
Y = Y5
pp = p5
}
true.x = X[n,pp]
# DFM fit
fit.dfm <- sparseDFM(Y, r = r, q = 0, alg = 'EM', err = 'IID', kalman = 'univariate',
standardize = TRUE, max_iter = 100, threshold = 1e-4)
dfm.est = fit.dfm$data$fitted.unscaled
dfm.est = dfm.est[n,pp]
dfm.mae[yidx] = mean(abs(dfm.est - true.x))
dfm.rmse[yidx] = sqrt(mean((dfm.est - true.x)^2))
#
# #sparseDFM fit
fit.sdfm <- sparseDFM(Y, r = r, q = 0, alg = 'EM-sparse', err = 'IID', kalman = 'univariate',
standardize = FALSE, max_iter = 100, threshold = 1e-4)
sdfm.est = fit.sdfm$data$fitted.unscaled
sdfm.est = sdfm.est[n,pp]
sdfm.mae[yidx] = mean(abs(sdfm.est - true.x))
sdfm.rmse[yidx] = sqrt(mean((sdfm.est - true.x)^2))
# AR(1) Benchmark
ar.est = c()
for(i in 1:length(pp)){
tryCatch({
fit.ar = arima(na.omit(Y[,pp[i]]), order=c(1,0,0))
print(fit.ar$coef[1])
ar.est[i] = as.numeric(predict(fit.ar,n.ahead = 3)$pred)[3]
}, error=function(e){})
}
ar.mae[yidx] = mean(abs(ar.est[!is.na(ar.est)] - true.x[!is.na(ar.est)]))
ar.rmse[yidx] = sqrt(mean((ar.est[!is.na(ar.est)] - true.x[!is.na(ar.est)])^2))
}
sdfm.mae.nexp = sdfm.mae.nexp + sdfm.mae
sdfm.rmse.nexp = sdfm.rmse.nexp + sdfm.rmse
dfm.mae.nexp = dfm.mae.nexp + dfm.mae
dfm.rmse.nexp = dfm.rmse.nexp + dfm.rmse
ar.mae.nexp = ar.mae.nexp + ar.mae
ar.rmse.nexp = ar.rmse.nexp + ar.rmse
}
sdfm.mae.p = sdfm.mae.nexp/num_exps
sdfm.rmse.p = sdfm.rmse.nexp/num_exps
dfm.mae.p = dfm.mae.nexp/num_exps
dfm.rmse.p = dfm.rmse.nexp/num_exps
ar.mae.p = ar.mae.nexp/num_exps
ar.rmse.p = ar.rmse.nexp/num_exps
sdfm.mae.p
dfm.mae.p
ar.mae.p
nexp=80
sdfm.mae.nexp = sdfm.rmse.nexp = dfm.mae.nexp = dfm.rmse.nexp = ar.mae.nexp = ar.rmse.nexp = rep(0,4)
set.seed(nexp)
Lambda = kronecker(diag(r),rep(1,p/r))
factors = tsDyn::VAR.sim(A, n, include = 'none', varcov = (1-0.8^2)*diag(r))
errors = MASS::mvrnorm(n, mu = rep(0,p), Sigma = 0.2*diag(p))
X = factors %*% t(Lambda) + errors
p2 = c(1:(p/12),(p/3+1):(p/3+p/12),(2*p/3+1):(2*p/3+p/12))
p3 =c(1:(p/6),(p/3+1):(p/3+p/6),(2*p/3+1):(2*p/3+p/6))
p4 = c(1:(3*p/12),(p/3+1):(p/3+3*p/12),(2*p/3+1):(2*p/3+3*p/12))
p5 = 1:p
# 1/4 missing in each block
Y2 = X
Y2[c(n-2,n-1,n),p2] = NA
# 1/2 missing in each block
Y3 = X
Y3[c(n-2,n-1,n),p3] = NA
# 3/4 missing in each block
Y4 = X
Y4[c(n-2,n-1,n),p4] = NA
# All missing
Y5 = X
Y5[c(n-2,n-1,n),p5] = NA
#################################
sdfm.mae = sdfm.rmse = dfm.mae = dfm.rmse = ar.mae = ar.rmse = c()
for(yidx in 1:4){
if(yidx==1){
Y = Y2
pp = p2
}else if(yidx==2){
Y = Y3
pp = p3
}else if(yidx==3){
Y = Y4
pp = p4
}else{
Y = Y5
pp = p5
}
true.x = X[n,pp]
# DFM fit
fit.dfm <- sparseDFM(Y, r = r, q = 0, alg = 'EM', err = 'IID', kalman = 'univariate',
standardize = TRUE, max_iter = 100, threshold = 1e-4)
dfm.est = fit.dfm$data$fitted.unscaled
dfm.est = dfm.est[n,pp]
dfm.mae[yidx] = mean(abs(dfm.est - true.x))
dfm.rmse[yidx] = sqrt(mean((dfm.est - true.x)^2))
#
# #sparseDFM fit
fit.sdfm <- sparseDFM(Y, r = r, q = 0, alg = 'EM-sparse', err = 'IID', kalman = 'univariate',
standardize = FALSE, max_iter = 100, threshold = 1e-4)
sdfm.est = fit.sdfm$data$fitted.unscaled
sdfm.est = sdfm.est[n,pp]
sdfm.mae[yidx] = mean(abs(sdfm.est - true.x))
sdfm.rmse[yidx] = sqrt(mean((sdfm.est - true.x)^2))
# AR(1) Benchmark
ar.est = c()
for(i in 1:length(pp)){
tryCatch({
fit.ar = arima(na.omit(Y[,pp[i]]), order=c(1,0,0))
print(fit.ar$coef[1])
ar.est[i] = as.numeric(predict(fit.ar,n.ahead = 3)$pred)[3]
}, error=function(e){})
}
ar.mae[yidx] = mean(abs(ar.est[!is.na(ar.est)] - true.x[!is.na(ar.est)]))
ar.rmse[yidx] = sqrt(mean((ar.est[!is.na(ar.est)] - true.x[!is.na(ar.est)])^2))
}
sdfm.mae.nexp = sdfm.mae.nexp + sdfm.mae
sdfm.rmse.nexp = sdfm.rmse.nexp + sdfm.rmse
dfm.mae.nexp = dfm.mae.nexp + dfm.mae
dfm.rmse.nexp = dfm.rmse.nexp + dfm.rmse
ar.mae.nexp = ar.mae.nexp + ar.mae
ar.rmse.nexp = ar.rmse.nexp + ar.rmse
fit.sdfm$params$A
sdfm.mae
dfm.mae
ar.mae
n = 300
p = 60
r = 3
sdfm.mae.nexp = sdfm.rmse.nexp = dfm.mae.nexp = dfm.rmse.nexp = ar.mae.nexp = ar.rmse.nexp = rep(0,4)
set.seed(nexp)
Lambda = kronecker(diag(r),rep(1,p/r))
factors = tsDyn::VAR.sim(A, n, include = 'none', varcov = (1-0.8^2)*diag(r))
errors = MASS::mvrnorm(n, mu = rep(0,p), Sigma = 0.2*diag(p))
X = factors %*% t(Lambda) + errors
p2 = c(1:(p/12),(p/3+1):(p/3+p/12),(2*p/3+1):(2*p/3+p/12))
p3 =c(1:(p/6),(p/3+1):(p/3+p/6),(2*p/3+1):(2*p/3+p/6))
p4 = c(1:(3*p/12),(p/3+1):(p/3+3*p/12),(2*p/3+1):(2*p/3+3*p/12))
p5 = 1:p
# 1/4 missing in each block
Y2 = X
Y2[c(n-2,n-1,n),p2] = NA
# 1/2 missing in each block
Y3 = X
Y3[c(n-2,n-1,n),p3] = NA
# 3/4 missing in each block
Y4 = X
Y4[c(n-2,n-1,n),p4] = NA
# All missing
Y5 = X
Y5[c(n-2,n-1,n),p5] = NA
#################################
sdfm.mae = sdfm.rmse = dfm.mae = dfm.rmse = ar.mae = ar.rmse = c()
for(yidx in 1:4){
if(yidx==1){
Y = Y2
pp = p2
}else if(yidx==2){
Y = Y3
pp = p3
}else if(yidx==3){
Y = Y4
pp = p4
}else{
Y = Y5
pp = p5
}
true.x = X[n,pp]
# DFM fit
fit.dfm <- sparseDFM(Y, r = r, q = 0, alg = 'EM', err = 'IID', kalman = 'univariate',
standardize = TRUE, max_iter = 100, threshold = 1e-4)
dfm.est = fit.dfm$data$fitted.unscaled
dfm.est = dfm.est[n,pp]
dfm.mae[yidx] = mean(abs(dfm.est - true.x))
dfm.rmse[yidx] = sqrt(mean((dfm.est - true.x)^2))
#
# #sparseDFM fit
fit.sdfm <- sparseDFM(Y, r = r, q = 0, alg = 'EM-sparse', err = 'IID', kalman = 'univariate',
standardize = FALSE, max_iter = 100, threshold = 1e-4)
sdfm.est = fit.sdfm$data$fitted.unscaled
sdfm.est = sdfm.est[n,pp]
sdfm.mae[yidx] = mean(abs(sdfm.est - true.x))
sdfm.rmse[yidx] = sqrt(mean((sdfm.est - true.x)^2))
# AR(1) Benchmark
ar.est = c()
for(i in 1:length(pp)){
tryCatch({
fit.ar = arima(na.omit(Y[,pp[i]]), order=c(1,0,0))
print(fit.ar$coef[1])
ar.est[i] = as.numeric(predict(fit.ar,n.ahead = 3)$pred)[3]
}, error=function(e){})
}
ar.mae[yidx] = mean(abs(ar.est[!is.na(ar.est)] - true.x[!is.na(ar.est)]))
ar.rmse[yidx] = sqrt(mean((ar.est[!is.na(ar.est)] - true.x[!is.na(ar.est)])^2))
}
sdfm.mae.nexp = sdfm.mae.nexp + sdfm.mae
sdfm.rmse.nexp = sdfm.rmse.nexp + sdfm.rmse
dfm.mae.nexp = dfm.mae.nexp + dfm.mae
dfm.rmse.nexp = dfm.rmse.nexp + dfm.rmse
ar.mae.nexp = ar.mae.nexp + ar.mae
ar.rmse.nexp = ar.rmse.nexp + ar.rmse
sdfm.mae
dfm.mae
ar.mae
